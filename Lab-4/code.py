import math

def get_max_vertex(k, V, S):
    m = 0   # найменше допустими значення
    v = -1
    for i, w in enumerate(V[k]):
        if i in S:
            continue

        if w[2] == 1:   # рух за стрілкою
            if m < w[0]:
                m = w[0]
                v = i
        else:           # рух проти стрілки
            if m < w[1]:
                m = w[1]
                v = i

    return v


def get_max_flow(T):
    w = [x[0] for x in T]
    return min(*w)


def updateV(V, T, f):
    for t in T:
        if t[1] == -1:  # це граф
            continue

        sgn = V[t[2]][t[1]][2]  # напрямок руху

        # міняємо ваги в таблиці для (i,j) і (j,i)
        V[t[1]][t[2]][0] -= f * sgn
        V[t[1]][t[2]][1] += f * sgn

        V[t[2]][t[1]][0] -= f * sgn
        V[t[2]][t[1]][1] += f * sgn


V = [[[0,0,1], [20,0,1], [20,0,1], [40,0,1], [0,0,1], [0,0,1], [0,0,1], [0,0,1]],
     [[20,0,-1], [0,0,1], [10,0,1], [0,0,1], [10,0,1], [0,0,1], [0,0,1], [0,0,1]],
     [[20,0,-1], [10,0,-1], [0,0,1], [20,0,1], [20,0,1], [10,0,-1], [0,0,1], [0,0,1]],
     [[40,0,-1], [0,0,1], [20,0,-1], [0,0,1], [0,0,1], [20,0,1], [20,0,1], [0,0,1]],
     [[0,0,1], [10,0,-1], [20,0,-1], [0,0,1], [0,0,1], [20,0,-1], [0,0,1], [30,0,1]],
     [[0,0,1], [0,0,1], [10,0,1], [20,0,-1], [20,0,1], [0,0,1], [10,0,-1], [20,0,1]],
     [[0,0,1], [0,0,1], [0,0,1], [20,0,-1], [0,0,1], [10,0,1], [0,0,1], [20,0,1]],
     [[0,0,1], [0,0,1], [0,0,1], [0,0,1], [30,0,-1], [20,0,-1], [20,0,-1], [0,0,1]],
]

N = len(V)  # число вершин в графі
init = 0    # вершина початку(нумерация с нуля)
end = 7     # вершина кінця
Tinit = (math.inf, -1, init)      # первая мітка (a, from, vertex)
f = []      # максимальні потоки знайдених маршрутів

j = init
while j != -1:
    k = init  # стартова вершина (нумерация с нуля)
    T = [Tinit]  # мітка маршрута
    S = {init}  # множина пройдених вершин

    while k != end:     # поки не дішли до кінця
        j = get_max_vertex(k, V, S)  # вибираємо вершину з найбільшой пропускною здібністю
        if j == -1:         # якшо наступних вершин нема
            if k == init:      # і ми на початку, то
                break          # завершуємо пошук маршрутів
            else:           # чи, переходимо до попередньої вершини
                k = T.pop()[2]
                continue

        c = V[k][j][0] if V[k][j][2] == 1 else V[k][j][1]   # визначаємо теперішній поток
        T.append((c, j, k))    # добавляєм мітку маршрута
        S.add(j)            # запамятовуємо вершину як пройдену

        if j == end:    # якшо дійшли до кінця
            f.append(get_max_flow(T))     # знаходимо максимальну пропускну здібність маршрута
            updateV(V, T, f[-1])        # обновляєм веги дуг
            break

        k = j

F = sum(f)
print(f"Максимальний потік рівний: {F}")
